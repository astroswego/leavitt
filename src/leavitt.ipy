from argparse import ArgumentParser, ArgumentError, FileType, SUPPRESS
from sys import stdin, stdout, stderr
from tempfile import NamedTemporaryFile as make_temp

def get_args():
    parser = ArgumentParser(
        prog="leavitt",
        description="Computes the distance modulus to the stars contained in "
            + "a table providing a name, logP and mean magnitudes in multiple "
            + "bands for each star. Table is input through stdin")
    general_group = parser.add_argument_group("General")
    output_group = parser.add_argument_group("Output")
    parameter_group = parser.add_argument_group("Parameters")

    # General
    general_group.add_argument("input_table", type=str,
        help="file name of input table")
    # Output
    output_group.add_argument("--equations-file", type=str,
        default=None,
        help="prefix of files to save systems of equations in")
    output_group.add_argument("--svd-file", type=str,
        default=None,
        help="prefix of files to save svd output in")
    output_group.add_argument("--modulus-file", type=str,
        default=None,
        help="prefix of files to save distance modulii in")
    output_group.add_argument("--distance-file", type=str,
        default=None,
        help="prefix of files to save kpc distances in")
    # Parameters
    parameter_group.add_argument("--mean-distance-modulus", type=float,
        default="18.41",
        help="mean distance modulus of target. "
             "defaults to mean LMC distance modulus (citation needed)")
    parameter_group.add_argument("-s", "--sigma", type=float,
        default=3.0,
        help="cutoff standard deviation for iterative sigma clipping")

    args = parser.parse_args()

    return args

def main():
    args = get_args()

    return process(args.input_table, **vars(args))

def process(input_file,
            *,
#            equations_file=None, modulus_file=None, distance_file=None,
            mean_distance_modulus=0,
            **kwargs):
    # store stdin in file

    # count the number of bands in the file,
    # which should be 2 fewer than the total number of columns
    n_cols, *_ = !head -n 1 $input_file | wc -w
    n_bands = int(n_cols) - 2
    
    return process_iter(input_file,
                        mean_distance_modulus,
                        n_bands, 0, **kwargs)

def process_iter(input_file,
                 mean_modulus,
                 n_bands, iteration,
                 *,
                 sigma,
                 equations_file=None, svd_file=None,
                 modulus_file=None, distance_file=None,
                 **kwargs):
    i = str(iteration)
    if equations_file is not None:
        _equations_file = equations_file + i
    else:
        _equations_file = make_temp('wb').name
    if modulus_file is not None:
        _modulus_file = modulus_file + i
    else:
        _modulus_file = make_temp('wb').name
    if distance_file is not None:
        _distance_file = distance_file + i
    else:
        _distance_file = make_temp('wb').name
    if svd_file is not None:
        _svd_file = svd_file + i
    else:
        _svd_file = make_temp('wb').name

    # create input matrix
    make_equations(input_file, _equations_file, n_bands)

    # find distance modulii and shift by target's mean modulus
    !Rscript ols.r $_equations_file --method svd --no-header \
       | tail -n +2 \
       | cut -d " " -f 2 \
       > $_svd_file

    !cat $_svd_file \
       | tail -n +$((1 + 2 * $n_bands)) \
       | awk -v const=$mean_modulus \
             -f addconst.awk \
       > $_modulus_file
       
    # convert distance modulii to kiloparsecs
    !cat $_modulus_file \
       | Rscript distmod.r \
       | awk -v divisor=1000 \
             -f divide.awk \
       > $_distance_file
    ## do sigma clipping here, and recur if not finished
    next_input_file = make_temp('wb').name
    !python sigma_clip.py $_distance_file $input_file --sigma $sigma \
       > $next_input_file

    original_star_count = !wc -l $input_file
    clipped_star_count = !wc -l $next_input_file

    if line_count(input_file) == line_count(next_input_file):
        # finally, print the final distances and exit
        !cat $input_file \
           | cut -d " " -f 1 \
           | paste - $_distance_file
        return 0
    else:
        return process_iter(next_input_file,
                            mean_modulus,
                            n_bands, iteration+1,
                            sigma=sigma,
                            equations_file=equations_file,
                            svd_file=svd_file,
                            modulus_file=modulus_file,
                            distance_file=distance_file)
        

    

def make_equations(input_file, equations_file, n_bands):
    _ = !wc -l $input_file
    lines = _.fields()[0][0]
    !> $equations_file
    for i in range(n_bands):
        !cat $input_file \
           | awk -v i=$i \
                 -v n=$n_bands \
                 -v lines=$lines \
                 -f column.awk \
           >> $equations_file

def line_count(filename):
    # count the lines in the file
    wc_output = !wc -l $filename
    # remove information other than line count, and convert to an int
    count = int(wc_output[0].strip().split()[0])

    return count
           
if __name__ == "__main__":
    main()
